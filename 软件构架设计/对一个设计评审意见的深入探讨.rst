.. Kenneth Lee 版权所有 2024

:Authors: Kenneth Lee
:Version: 0.1
:Date: 2024-04-02
:Status: Draft

对一个设计评审意见的深入探讨
****************************

昨天收到一个设计的评审意见，我觉得可以作为深入探讨设计外延\ [#extension]_\ 的
好例子。本文对这个主题进行一些论述。

.. [#extension] :ref:`s_extension`

这个意见，去掉和细节相关的信息后，大致是这样的：

  | 你说的优化点3，现在编译器没有实现，但我看到文档其他地方也有一些没有落进去
  | 设计，这可以作为一个例子，你觉得合适就放着吧。

这个意见让我嗅到了危险的味道，进而让我担心起其他的评审意见来。因为这段意见反映
了评审者对“设计是什么”的理解可能都是错的，这一点如果双方没有一样的认识，那谈什
么都是鸡和鸭讲。

我说的“错误理解”主要包括两点：

1. 设计是设计未来，而不是描述现在。所以现在编译器没有实现，和设计不直接相关。
2. 设计是严谨的模糊约束，不是“你觉得合适”的问题。

我重点想谈的是第二点，但为了谈第二点，我们首先理解一下第一点。我经常用从深圳出
差去北京作为具象来谈设计的问题，这样大部分人都有共同的基础认识。所以我们继续用
这个例子来具象化理解这个第一点。

知道要出差北京了，马上出门向北跑，这显然就是“没有设计”，有设计的行为是先考虑大
的：坐飞机还是高铁去？去几天？票什么时候有？都什么价钱？这些几乎都不是和“到北
京”直接相关的，但这些是做这件事的关键控制点（主要矛盾或者矛盾的主要方面）。如
果我们直接开始做那件事（出门往北跑），那我们就容易走错方向，因为没有一件复杂的
事情是可以按直线操作就完成的。要去机场你可能需要往南走，但只有往南走你才能真的
到达北京，向北走你大概率饿死在半路上。

所以，我们谈设计，本来谈的就是端到端的，我们要达成目标的每个关键要素（或者说特
征），我们保证这些要素被实现了，我们就“愈加靠近我们的目标”了。特征之间的逻辑空
隙（比如如何从家里到机场），是留给下一层设计的。留下这个空隙，本来就是设计的本
意。设计就是为了在路径上给细节插上标杆，保证我们可以走在正确的路上的。

那么“编译器现在没有实现某个优化点”，这个信息是否应该呈现在设计中呢？这要两说：
如果这些信息可以证明：“这个工作量很大，我们一点都还没有做，所以最终决策中不能
使用这个优化点。”，那这个信息应该呈现。因为它是构成我们前面说的那个“到达目标的
路径”逻辑链的一部分。

但如果这个信息用来证明：“编译器现在没有做这个功能，所以设计这样写不符合事实”，
那这个信息就是错的，因为这个逻辑建立的前提就不对：设计是为未来服务的。

好了，理解了这一点，我们应该可以理解第二点的前提了：“设计是严谨的模糊约束”。设
计是模糊的，因为它确实不会描述关键控制要素之外的细节。但设计也是严谨的，因为设
计加入的每个控制要求，都是我们逻辑链上必须的。这个约束出现，要不是因为证明这个
逻辑链，我们必须有这个控制要求；要不就是错误的，不应该加这个约束，而应该留给细
节设计作为自由度。多余的约束，在设计上会给细节设计留下过多的限制，这个上一层的
设计就犯错了。比如高层逻辑要求在某个地方实现一个算法，设计者因为个人喜好要求：
算法必须用Ocaml实现。结果这个和达成目的没有任何关系，本来这个算法有现成的C++库
可以用的，现在被迫开发了半年。那这个设计约束就非常失败了。

所以，没有一个设计点是可以“你觉得合适就可以”的。要不合适，要不不合适，没有其他
观点。设计是技术上权衡利弊，不是工程师互相卖人情。设计给定的约束确实有猜的成分
（参考：\ :doc:`架构设计中猜的成分`\ ），但这种猜也是基于当前所有信息的猜，不
是“都可以”，设计本来就是执行前的筹划，你要说“都可以”，其实什么都行，反正不用执
行，但我们所有目的都是为未来真的可以服务的。从这个角度说，设计点还是只有合适或
者不合适两种情况，不是“都可以”的。

设计，特别是架构设计，通常都是一群人的工作。做一个大型的产品，我们可能有人做软
件，有人做硬件，有人做芯片，有人做开发，有人做测试，有人做营销，有人写文档。每
个人的经验都不一样，了解的细节不同。我们在架构设计上共享我们的细节经验，得到一
个大部分都认可的“共识”。所以设计通常是这样组成的：

1. 首先我们会分很多层，这样让所有人都知道端到端的整件事是怎么做成的，这里模糊
   了很多的细节，但大家至少知道别人是怎么承认那个细节是可以实现的。同时可以依
   托一个树状的结构，找到自己熟悉的领域。

2. 我们会在每一层写下我们针对各种细节的“总结”，这些总结有猜的成分，置信度有高
   有低，但我们做成整件事就靠这些总结来搭，所以我们尽量找对我们这群人置信度最
   高的事情来总结。

3. 我们用这些总结的结论来搭建逻辑，来说明整件事情如何达成。

用维特根斯坦的理论来解释，我们写的“总结”，就是所谓的“Can be said clearly”（可
以说清楚）的部分，而这个总结如何被得到的，就是所谓的“Must be passed over in
silence”（只能在沉默中传递）的部分。而最后的设计，就是用所有Can be said
clearly的观点，搭建一个逻辑公式，说明事情如何做成。对于一群不同领域的专家组成
的高层（架构）设计，这个Must be passed over in silence的部分会特别显眼，因为确
认我们每个人对对方的细节其实都是非常缺乏认知的。

所以，我们评审一个设计的过程，包括两个部分：第一部分，是每个专业领域的专家，都
来看，这些Can be said clearly的部分，是不是可以接受。第二部分，在这些Can be
said clearly的部分被大部分人认可后（包括其中猜测的成分被大部分人认为可以冒这个
险），所有人一起来校验基于它们搭建的逻辑是否正确。

这其中，其实最难的是第一部分。Can be said clearly的部分，三言两语就可以说清楚
了，但如果它的基础都是错的，那说多少都没有用。我们评审一个设计的时候，主要工作
量，其实是在这里。但按维特根斯坦的理论，这个结论的语义，取决于我们在Can be
said clearly的时候，使用了它的什么属性。所以，对于这个结论的认识，也需要结合着
我们怎么使用这个结论来理解。关于这一点，请参考下面对内涵和外延的解释。

总结起来，评审的时候，也请聚焦到“校验结论”-“校验逻辑”这个逻辑上，不能觉得“反正
又不马上用，差不多就行了”。我们其实想要的是评审者关于“某某结论其实不成立，因为
在细节上，有巴拉巴拉这样一个问题……”，或者“就算这些结论都成立，但你没有考虑到巴
拉巴拉的情况，所以这个方案风险还是很大”这样的意见，这些才是有效的评审意见。

.. _`s_extension`:

关于内涵和外延的一些补充说明
============================

内涵和外延都是一个语义的一部分，但我们很容易犯的一个错误是用内涵代替了语义，导
致我们做出很多错误的判断。所以我们这里必须澄清一下，这样读者可能会更容易理解本
文说的问题。

内涵通常指我们直接区分一个概念的方法，比如熟，你查字典，它其中一个解释是：

  | 食物烧煮到可吃的程度。

当然，熟这个字本身还有其他解释，但我们可以简单理解为这是一字多用。在我们这个讨
论中，我们认为熟就是这个语义。这里我们有了一个判断标准，“烧煮到可吃的程度”，我
们很容易由此区分开“熟”和“不熟”的区别，这个我们称为“内涵”。我们查字典主要查到的
都是内涵。但内涵并不能严格定义一个词语的语义。因为，这里还有一个关键在于，我们
区分了这个东西，是为了什么目的。

比如熟这个问题，我们关心熟不熟（集合内还是集合外），可能有很多理由：

* 熟的卖的贵，生的买得便宜
* 熟的不好保存，生成好保存
* 熟的吃了身体好，生的吃了容易被细菌感染
* 等等

内涵定义了一个集合，而外延定义了其他集合，其实两者区分不那么严格。因为我们完全
可以用其中一个外延来取代内涵的。比如：

  | 食物好保存的程度

不过，通常我们会选择一个最容易区分，而且最容易用作其他外延的子集的集合来做内涵，
因为这样好用。我们在设计中关心内涵和外延，其实就是在校验我们选择的这个名字（用
了它的内涵），是否确实是我们需求中的外延的最小集合？我们是否被名字的内涵左右了，
顾着内涵忘掉了我们的原始需求？如果我们的目的仅仅就是某个特定的外延，我们是否应
该改用这个外延作为我们的新概念的内涵，而不应该继续用原来的内涵？

这种情况下，区分内涵和外延就很有必要了。这本质就是所谓的“第一性原理”：我们回到
原始需求上，不是被已有的概念左右自己的思路。就好比你做一套新的指令，谁说指令就
必须是一个连续的执行序列？谁说指令必须一条条执行的？谁说访问内存就必须用访存指
令，一定要经过VMMA做地址翻译？做这些东西背后的驱动需求是什么？我们需要那个需求
吗？想明白这些问题，我们才有可能轻装上阵，扔下过去的负担，在新的现实面前走到新
的高度上。
