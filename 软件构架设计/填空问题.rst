.. Kenneth Lee 版权所有 2025

:Authors: Kenneth Lee
:Version: 0.1
:Date: 2025-02-28
:Status: Draft

填空问题
********

设计文档的“填空”问题我在单位内部写过多个博客进行批判。这两天评审一个设计文档的
时候又发现多个例子，我就想补充到到这里来。才发现这里从来没有讨论这个问题，所以
我就着记录这些例子的机会，在这里也总结一下这个问题。

我们做设计，是把产品做成的需要，对于一个较大的产品或者软件，我们要考虑的，会遇
到的问题都非常多，我们经常要在无数的细节中找到问题的“主要矛盾和主要的矛盾方面”。
为了保证我们正确抓住这些主要矛盾和主要的矛盾方面，我们需要建立一个或者多个“视
图（View）”：我们看到了产品设计的无数细节，我们挑出某个方面的关键信息，把这些
信息组合到一个逻辑空间中，从而可以在一个封闭的空间中对问题进行推理。

具象化举一个例子：你写一个内存分配函数，你看到的细节是函数入口参数（比如size），
可以分配的内存的整个空间。但凭这个信息你可以写好这个程序吗？很难，你要分别考虑
如下视图：

1. 有多少个线程按什么样的规律访问这片内存？
2. 你提供的API的全集是什么？除了可以malloc，还可以realloc吗？会有对齐要求吗？
   会有缺页保护的要求吗？会对内存使用的NUMA节点有要求吗？
3. 出错要循什么出错流程处理？直接系统异常？返回错误码？设置全局错误变量（比如
   errno）？还是自动修复？
4. ……

这些每个考虑的角度，就是一个设计方面的视图。不独立考虑一个个这样的视图，只盯着
malloc这个函数的实现，你没法写好这个函数。而这些视图基本上没法写成程序，到头来，
它们就会变成设计，或者呈现为设计文档。

我这里举的例子还是相对简单的，很多这种设计只简单“记在心中”就可以。但如果把这个
要求放大，比如变成“设计一台服务器”，或者“设计一个指令集”，不落实成文档，几乎没
有办法维护这么多复杂的逻辑。不管理这种设计，我们通常也能设计出产品——的第一个版
本，甚至运气好一点——的几个版本，但基本上都延续不下去。因为产品初期就几个功能几
个场景，有大把的余量让你规避冲突，但等功能都加上来后，这个你怎么加逻辑都没法不
和其他功能冲突了。

如果要对应前面的例子，你的内存分配可能也就一个线程访问，所以你不上锁也无所谓，
或者你上了锁，性能也不会受影响。但如果变成有多个线程访问呢？访问的并行度需要很
高呢？中间还有可能在信号处理和中断处理中处理呢？一开始的逻辑空间如果没有考虑这
些要素，后面的逻辑根本就补充不进去。甚至可能你一开始就没有考虑过这个问题，就这
样加入了很多的代码，之后你在多线程访问下逻辑到底可以自洽还是不能自洽呢？你根本
就不知道，因为你又看不完那么多代码，你怎么知道怎么代码里面具体有没有考虑到两个
线程上下文同时访问会不会错呢？

这就是设计的必要性，没有设计，长远来说，代码根本很难维护，甚至都不用进入维护阶
段，在开发阶段可能就会因为第一波需求没法综合在一起就失败了。

但初学者还在学习代码的反馈，对代码的反馈缺乏认识，写下的代码不跑一下他都不一定
知道结果是什么样的，这种情况你要求他能提前考虑到其他要求，就很难了。这种没什么
可说的，他们只能写一些简单的代码，如果需要做产品，就需要系统工程师带着。

但慢慢这些人会成长，他们也开始做设计了，这些刚刚进入设计的工程师，不一定能这么
快搞明白设计的必要性，因为他们的成功都来自“直接编码”。他们只是在“名义”上觉得
“设计师”都是上司，很厉害，都听说“设计(文档）”，但他们还没有感受到设计有什么用，
也不知道为什么要写设计文档。他们写设计文档是完成某个仪式，而不是认为设计是帮助
他编码的。

我在本文中要说的这个“填空”说的就是这种情况：设计师因为某种仪式要求，自己觉得需
要学习设计也行，某个公司的开发流程要求也罢，决定要写文档了，写这个文档他只是为
了完成这个仪式，要写一个“正确”的文档，而不是因为“代码直接编编不下去”，或者“没
把握这个代码这样假设是不是可以”，所以才决定写一个文档。

这样不带设计目标，而仅仅是为了完成某个仪式而写的“设计文档”，就叫填空。还是用前
面的malloc函数为例，如果他看到别人的设计文档中有个“设计约束”的章节，可能他也会
学着写一个这样的章节。但别人做这个设计，可能是因为有一些严格的外在要求，不放在
这里推整个推理不利，所以才加进来的。比如他可能收到一个要求：“要分配的内存是非
连续的，但以页为粒度的”，这就是一个“设计约束”，设计师考虑他的算法的时候要时刻
考虑到让自己记录可用内存的时候要用非连续的数据结构去记录它。之后到底是多少个线
程上下文来访问这个内存呢？没人告诉他，但这个对他的算法影响很大，他可能又会增加
一个“假设”的章节，说明他的设计是建立在“有多个线程同时来访问”这个基础上的。
这些设计都是有效的。

但只会填空的设计师可能也会写“设计约束”和“假设”的章节，但他并没有体会到这两个条
件的重要性。他可能写的约束是“必须用C语言写”，这句话没有错，但并没有外在约束他
必须用C语言写，他只是选择了使用C语言来写，这个根本不是他的约束，他这个约束的设
计，就成了一个“填空”了。同样，他的假设也有可能写“支持多线程访问”（因为他看过他的
“前辈”是这样写的），但他的需求不一定是这样，这样的结果，也是让设计变成一个“填
空”了。还有更多的，把写好的代码拷贝到文档中，显得自己在写一个设计文档。这都是
“填空”的例子。

我这次要记录的“填空”的例子是这样的：我评审的是一个指令集手册。我之前已经写了一
部分通用指令的介绍了，我是把这些指令直接分类存放就好了，因为通用指令嘛，你没有
什么好介绍的，除了一些内存读写指令有相关性我用了一章单独介绍外，其他的算法类的，
都罗列就行了。

但这位新加指令的设计师，他做的是一个加速功能，指令之间的关系是很密切的，他也学
我之前的写法一样，也直接出一个列表就算“写完”了。这就是我前面说的“填空”，我和他
沟通的时候，发现可以这样说明白给他听：你考虑你是一个开发者，你仅仅看到你提供的
每条指令，但不告诉你必须先调用谁，再调用谁，也不总结你这个功能加入了多少个寄存
器，你能写出代码来吗？

所以，我发现对刚开始做设计的工程师来说，也许可以通过这样的心法来自己判断自己是
在做设计还是在填空：如果我不做这个设计，影响了谁？是谁（自己或者用户都行）不看
我的结论（约束）会在设计中留下破绽？如果找不到这个人，那么你的设计就是“填空”了。

我在评审他的设计中还发现一个问题：他把一个单独的功能，放到两条指令上了（因为一
条指令放不下这种信息），我就挑刺说，如果两条指令中间发生了中断会怎么样，或者我
不连续写两条指令怎么样？

这不完全是“填空”的问题，更像是缺乏“可能性穷举”的问题，但我也要把这个例子放到这
里来，因为如果站在“用户看到这个定义如何写代码”的角度上，这个问题可以用前面一样
的心法去校验。

不过，设计的时候如果想不到这些可能性的工程师，可能也没有能力想到用户也是需要穷
举所有的可能性的。这个只能说提一嘴罢了。
